/**
    @file pico_gl.h
    @brief A powerful graphics library based on Sokol GFX, written in C99.

    ----------------------------------------------------------------------------
    Licensing information at end of header
    ----------------------------------------------------------------------------

    Features:
    ---------
    - Written in C99
    - Single header library for easy build system integration
    - Easy to use Low-level constructs (render passes and pipelines)
    - Simple texture and shader creation
    - Default shader and uniform block
    - Render to texture
    - Rendering of dynamic vertex arrays, indexed arrays
    - Rendering of static vertex buffers
    - Simple API for managing uniform blocks
    - Straight foward state management (state stack)
    - Simple and concise API
    - Permissive license (zlib or public domain)

    Summary:
    --------
    PicoGFX is a wrapper for the sokol_gfx, a low-level wrapper for OpenGL,
    Metal, and D3D. PicoGFX is designed to make the common case intuitive and
    convenient for 2D applications. It provides access to low-level
    primititives, such as render passes and pipelines, in a way that is easy to
    use and understand.

    PicoGFX includes a default shader (and pipeline), but can be extended using
    the sokol shader compiler (`sokol-shdc`) that allows for a shader to be
    written in a single language (GLSL) which is then transformed into shader
    sources for all suppported backends.

    One thing PicoGFX does not support (and neither does sokol_gfx) is window or
    graphics context creation. See [here](https://github.com/RandyGaul/cute_framework/tree/master/src/internal)
    for some examples. It is worth mentioning that [SDL2](https://www.libsdl.org)
    can supply both a window and OpenGL context out of the box. SDL2 is used
    in the demos.

    State (pipeline/shader, the viewport, scissor, and clear color) can be
    managed via the state stack. The stack enables changes to be isolated.
    Simply push the current state to the top of the stack, make some local
    changes, and then pop the stack to restore the original state.

    Shaders expose uniforms in blocks. These blocks must be registered with the
    shader by calling `pg_register_uniform_block`. They may then be set at will
    by calling `pg_set_uniform_block`. These functions typically operate on
    structs supplied by a custom shader,

    The default shader and pipeline provides a

    Please see the examples for more details.

    To use this library in your project, add

    > #define PICO_GFX_IMPLEMENTATION
    > #include "pico_gfx.h"

    to a source file.

    You must also define one of

    #define PICO_GFX_GL
    #define PICO_GFX_GLES
    #define PICO_GFX_D3D
    #define PICO_GFX_METAL
    #define PICO_GFX_WEBGPU

    bofore including pico_gfx.h

    IMPORTANT: sokol_gfx.h must be in the include path!

    See the examples for build details.

    Constants:
    --------

    - PICO_GFX_STACK_MAX_SIZE (default: 16)
    - PICO_GFX_BUFFER_SIZE (default: 1024)

    Must be defined before PICO_GFX_IMPLEMENTATION
*/

#ifndef PICO_GFX_H
#define PICO_GFX_H

// Backend conversion macros
#if defined (PICO_GFX_GL)
    #define SOKOL_GLCORE33
#elif defined (PICO_GFX_GLES)
    #define SOKOL_GLES3
#elif defined (PICO_GFX_D3D)
    #define SOKOL_D3D11
#elif defined (PICO_GFX_METAL)
    #define SOKOL_METAL
#elif defined (PICO_GFX_WEBGPU)
    #define SOKOL_WGPU
#else
    #error "GFX backend must be specified"
#endif

#include "sokol_gfx.h"

#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Drawing primitives
 */
typedef enum
{
    PG_DEFAULT_PRIMITIVE,
    PG_POINTS,         //!< Array of points
    PG_LINES,          //!< Each adjacent pair of points forms a line
    PG_LINE_STRIP,     //!< Array of points where every pair forms a lines
    PG_TRIANGLES,      //!< Each adjacent triple forms an individual triangle
    PG_TRIANGLE_STRIP, //!< Array of points where every triple forms a triangle
} pg_primitive_t;

/**
 * @brief Blend factors
 */
typedef enum
{
    PG_DEFAULT_BLEND_FACTOR,
    PG_ZERO,                //!< (0, 0, 0,  0)
    PG_ONE,                 //!< (1, 1, 1, 1)
    PG_SRC_COLOR,           //!< (src.r, src.g, src.b, src.a)
    PG_ONE_MINUS_SRC_COLOR, //!< (1, 1, 1, 1) - (src.r, src.g, src.b, src.a)
    PG_DST_COLOR,           //!< (dst.r, dst.g, dst.b, dst.a)
    PG_ONE_MINUS_DST_COLOR, //!< (1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a)
    PG_SRC_ALPHA,           //!< (src.a, src.a, src.a, src.a)
    PG_ONE_MINUS_SRC_ALPHA, //!< (1, 1, 1, 1) - (src.a, src.a, src.a, src.a)
    PG_DST_ALPHA,           //!< (dst.a, dst.a, dst.a, dst.a)
    PG_ONE_MINUS_DST_ALPHA, //!< (1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a)
} pg_blend_factor_t;

/**
 * @brief Blend equations
 */
typedef enum
{
    PG_DEFAULT_BLEND_EQ,
    PG_ADD,              //!< result = src * src_factor + dst * dst_factor
    PG_SUBTRACT,         //!< result = src * src_factor - dst * dst_factor
    PG_REVERSE_SUBTRACT, //!< result = dst * dst_factor - src * src_factor
} pg_blend_eq_t;

/**
 * @brief Blend mode
 *
 * Completely describes a blend operation.
 */
typedef struct
{
    pg_blend_factor_t color_src; //!< Color source blending factor
    pg_blend_factor_t color_dst; //!< Color dsestination blending factor
    pg_blend_eq_t     color_eq;  //!< Equation for blending colors
    pg_blend_factor_t alpha_src; //!< Alpha source blending factor
    pg_blend_factor_t alpha_dst; //!< Alpha destination blending factor
    pg_blend_eq_t     alpha_eq;  //!< Equation for blending alpha values
} pg_blend_mode_t;

/**
 * @brief A vertex describes a point and the data associated with it (color and
 * texture coordinates)
 */
typedef struct
{
    float pos[3];
    float color[4];
    float uv[2];
} pg_vertex_t;

/**
 * @brief Shader stage
*/
typedef enum
{
    PG_VS_STAGE, //!< Vertex shader stage
    PG_FS_STAGE  //!< Fragment shader stage
} pg_stage_t;

typedef float pg_mat4_t[16];

/**
 * @brief Contains core data/state for an instance of the graphics library
 */
typedef struct pg_ctx_t pg_ctx_t;

/**
 * @brief Render pass. Writes draw calls to a render target or the window
 */
typedef struct pg_pass_t pg_pass_t;

/**
 * @brief Render state information
 */
typedef struct pg_pipeline_t pg_pipeline_t;

/**
 * @brief Vertex/fragment shader program
 */
typedef struct pg_shader_t pg_shader_t;

/**
 * @brief Represents an image or render target in VRAM
 */
typedef struct pg_texture_t pg_texture_t;

/**
 * @brief A vertex array
 */
typedef struct pg_vbuffer_t pg_vbuffer_t;

/**
 * @brief Loads pico_gfx and sokol_gfx
 *
 * IMPORTANT: A valid graphics context must exist for this function to succeed.
 * This function must be called before any other pico_gfx functions.
 *
 * NOTE: This function calls `sg_setup`.
 */
void pg_init();

/**
 *  @brief Tears down pico_gfx and sokol_gfx
 *
 * NOTE: This function calls `sg_shutdown`
 */
void pg_shutdown();

/**
 * @brief Creates a graphics context
 * @param window_width The window width
 * @param window_height The window height
 */
pg_ctx_t* pg_create_context(int window_width, int window_height);

/**
 * @brief Destroys a graphics context
 */
void pg_destroy_context(pg_ctx_t* ctx);

/**
 * @brief Creates a render pass
 * @param texture The render target
 */
pg_pass_t* pg_create_pass(pg_texture_t* texture);

/**
 * @brief Destroys a render pass
*/
void pg_destroy_pass(pg_pass_t* pass);

/**
 * @brief Starts a render pass (mandatory)
 * @param ctx The graphics context
 * @param pass The render pass (NULL for the default pass)
 * @param clear Clears the render target or window
 */
void pg_begin_pass(pg_ctx_t* ctx, pg_pass_t* pass, bool clear);

/**
 * @brief Ends a render pass (mandatory)
 */
void pg_end_pass(pg_ctx_t* ctx);

/**
 * @brief Flush commands
 *
 * Must be called at the end of a frame (after `pg_end_pass`).
*/
void pg_flush(pg_ctx_t* ctx);

/**
 * @brief Pushes the active state onto the stack.
 *
 * State consists of the pipeline, draw color, scissor, and viewport.
 */
void pg_push_state(pg_ctx_t* ctx);

/**
 * @brief Pops a state off the stack and makes it the active state
 */
void pg_pop_state(pg_ctx_t* ctx);

/**
 * @brief Resets the active state to defaults
 */
void pg_reset_state(pg_ctx_t* ctx);

/**
 * @brief Sets the pipeline state
 * @param ctx The graphics context
 * @param pipeline The pipeline to be placed on the top of the state stack
 */
void pg_set_pipeline(pg_ctx_t* ctx, pg_pipeline_t* pipeline);

/**
 * @brief Sets the clear color state to be placed at the top of the state stack
 */
void pg_set_clear_color(pg_ctx_t* ctx, float r, float g, float b, float a);

/**
 * @brief Sets the viewport state to be placed at the top of the state stack
 */
void pg_set_viewport(pg_ctx_t* ctx, int x, int y, int w, int h);

/**
 * @brief Sets the scissor state to be placed at the top of the state stack
 */
void pg_set_scissor(pg_ctx_t* ctx, int x, int y, int w, int h);

/**
 * @brief Creates the shader with the given prefix
 * The prefix should refer to the shader program name in a shader compiled by
 * `sokol-shdc`
 */
#define pg_create_shader(prefix)        \
    pg_create_shader_internal(          \
        (pg_shader_internal_t)          \
        {                               \
		    prefix##_shader_desc,       \
		    prefix##_uniformblock_slot, \
        }                               \
    )

/**
 * @brief Destroys a shader
 */
void pg_destroy_shader(pg_shader_t* shader);

/**
 * @brief Returns the default shader
 */
pg_shader_t* pg_get_default_shader(const pg_ctx_t* ctx);

/**
 * @brief Returns the default pipeline
 */
pg_pipeline_t* pg_get_default_pipeline(const pg_ctx_t* ctx);

/**
 * @brief Returns a shader ID
 */
uint32_t pg_get_shader_id(const pg_shader_t* shader);

/**
 * @brief Registers a uniform block (UB)
 * @param shader The shader owning the UB
 * @param name The string name of the UB
 * @param stage The stage (VS or FS) associated with the UB
 * @param size  The size of the UB struct
 */
void pg_register_uniform_block(pg_shader_t* shader,
                               pg_stage_t stage,
                               const char* name,
                               size_t size);

/**
 * @brief Sets a uniform block (UB)
 * @param shader The shader owning the UB
 * @param name The string name of the UB
 * @param data The data to set (must be the whole UB)
 */
void pg_set_uniform_block(pg_shader_t* shader,
                          const char* name,
                          const void* data);

/**
 * @brief Creates a rendering pipeline (encapsulates render state)
 * @param primitive The rendering primitive (points, triangles etc...)
 * @param target True if the current pass is rendering to a texture, false otherwise
 * @param indexed True if the pipeline is using indexed rendering, false otherwise
 * @param shader The shader used by this pipeline
 * @param blend_mode The blending mode used by this pipeline
 */
pg_pipeline_t* pg_create_pipeline(pg_primitive_t primitive,
                                  bool target,
                                  bool indexed,
                                  pg_shader_t* shader,
                                  const pg_blend_mode_t* blend_mode);

/**
 * @brief Destroys a render pipeline
*/
void pg_destroy_pipeline(pg_pipeline_t* pipeline);

/**
 * @brief Creates a texture from a bitmap
 * @param width Bitmap width
 * @param height Bitmap height
 * @param data Bitmap data (format must be RGBA8)
 * @param mipmaps Mipmap level
 * @param smooth Linear filtering (vs nearest)
 * @param repeat Repeat (vs clamp-to-edge)
 */
pg_texture_t* pg_create_texture(int width, int height,
                                const uint8_t* data, size_t size,
                                int mipmaps, bool smooth, bool repeat);

/**
 * @brief Creates a render target (RT)
 * @param width RT width
 * @param height RT height
 * @param mipmaps Mipmap level
 * @param smooth Linear filtering (vs nearest)
 * @param repeat Repeat (vs clamp-to-edge)
 */
pg_texture_t* pg_create_render_texture(int width, int height,
                                       int mipmaps,
                                       bool smooth, bool repeat);

/**
 * @brief Destroys a texture
 */
void pg_destroy_texture(pg_texture_t* texture);

/**
 * @brief Returns a texture ID
 */
uint32_t pg_get_texture_id(const pg_texture_t* texture);

/**
 * @brief Gets a texture's dimensions
 */
void pg_get_texture_size(const pg_texture_t* texture, int* width, int* height);

/**
 * @brief Creates a vertex buffer
 */
pg_vbuffer_t* pg_create_vbuffer(const pg_vertex_t* vertices, size_t count);

/**
 * @brief Destroys a vertex buffer
 */
void pg_destroy_vbuffer(pg_vbuffer_t* buffer);

/**
 * @brief Draws a vertex buffer
 * @param ctx The graphics context
 * @param buffer An array of vertices
 * @param start The first vertex to draw
 * @param count The number of vertices to draw
 * @param texture The texture to draw from
 */
void pg_draw_vbuffer(const pg_ctx_t* ctx,
                     const pg_vbuffer_t* buffer,
                     size_t start, size_t count,
                     pg_texture_t* texture);

/**
 * @brief Draws an array of vertices
 * @param ctx The graphics context
 * @param vertices An array of vertices (position, color, uv)
 * @param count The number of vertices
 * @param texture The texture to draw from
 */
void pg_draw_array(pg_ctx_t* ctx,
                   const pg_vertex_t* vertices, size_t count,
                   pg_texture_t* texture);

/**
 * @brief Draws an indexed array of vertices
 * @param ctx The graphics context
 * @param vertices An array of vertices (position, color, uv)
 * @param vertex_count The number of vertices
 * @param indices An array that indexes into the vertex array
 * @param index_count The number of indices
 * @param texture The texture to draw from
 */
void pg_draw_indexed_array(pg_ctx_t* ctx,
                           const pg_vertex_t* vertices, size_t vertex_count,
                           const uint32_t* indices, size_t index_count,
                           pg_texture_t* texture);


void pg_set_identity(pg_ctx_t* ctx);
void pg_set_projection(pg_ctx_t* ctx, pg_mat4_t matrix);
void pg_set_modelview(pg_ctx_t* ctx, pg_mat4_t matrix);

/*=============================================================================
 * Types
 *============================================================================*/

#if !defined(PICO_GFX_ALIGN)
    #if defined(_MSC_VER)
        #define PICO_GFX_ALIGN(a) __declspec(align(a))
    #else
        #define PICO_GFX_ALIGN(a) __attribute__((aligned(a)))
    #endif
#endif

#pragma pack(push,1)
PICO_GFX_ALIGN(16) typedef struct pg_vs_block_t {
    pg_mat4_t u_proj;
    pg_mat4_t u_mv;
} pg_vs_block_t;
#pragma pack(pop)

/*=============================================================================
 * Internals
 *============================================================================*/

typedef struct
{
	const sg_shader_desc* (*get_shader_desc)(sg_backend backend);
	int (*get_uniformblock_slot)(sg_shader_stage stage, const char* ub_name);
} pg_shader_internal_t;

pg_shader_t* pg_create_shader_internal(pg_shader_internal_t internal);

#ifdef __cplusplus
}
#endif

#endif // PICO_GFX_H

/*=============================================================================
 * Implementation
 *============================================================================*/

#ifdef PICO_GFX_IMPLEMENTATION

#include <string.h>

/*=============================================================================
 * Constants
 *============================================================================*/

#ifndef PICO_GFX_STACK_MAX_SIZE
#define PICO_GFX_STACK_MAX_SIZE 16
#endif

#ifndef PICO_GFX_BUFFER_SIZE
#define PICO_GFX_BUFFER_SIZE 1024
#endif

/*=============================================================================
 * Macros
 *============================================================================*/

#ifdef NDEBUG
    #define PICO_GFX_ASSERT(expr) ((void)0)
#else
    #ifndef PICO_GFX_ASSERT
        #include <assert.h>
        #define PICO_GFX_ASSERT(expr) (assert(expr))
    #endif
#endif

#if !defined(PICO_GFX_MALLOC) || !defined(PICO_GFX_REALLOC) || !defined(PICO_GFX_FREE)
#include <stdlib.h>
#define PICO_GFX_MALLOC(size)       (malloc(size))
#define PICO_GFX_REALLOC(ptr, size) (realloc(ptr, size))
#define PICO_GFX_FREE(ptr)          (free(ptr))
#endif

#ifndef PICO_GFX_LOG
    #include <stdio.h>
    #define  PICO_GFX_LOG(...) (pg_log(__VA_ARGS__))
#endif

/*=============================================================================
 * GFX Static Funtions
 *============================================================================*/

static sg_primitive_type pg_map_primitive(pg_primitive_t primitive);
static sg_blend_factor pg_map_blend_factor(pg_blend_factor_t factor);
static sg_blend_op pg_map_blend_eq(pg_blend_eq_t eq);
static sg_shader_stage pg_map_stage(pg_stage_t stage);

static void pg_log_sg(const char* tag,              // e.g. 'sg'
                      uint32_t log_level,           // 0=panic, 1=error, 2=warn, 3=info
                      uint32_t log_item_id,         // SG_LOGITEM_*
                      const char* message_or_null,  // a message string, may be nullptr in release mode
                      uint32_t line_nr,             // line number in sokol_gfx.h
                      const char* filename_or_null, // source filename, may be nullptr in release mode
                      void* user_data);

static void pg_log(const char* fmt, ...);

/*=============================================================================
 * Utility
 *============================================================================*/

static size_t pg_str_copy(char* dst, const char* src, size_t n)
{
    return snprintf(dst, n, "%s", src);
}

static bool pg_str_equal(const char* s1, const char* s2)
{
    return strcmp(s1, s2) == 0;
}

/*=============================================================================
 * Hashtable
 *============================================================================*/

#ifdef PICO_GFX_32BIT
    typedef uint32_t pg_hash_t;
#else
    typedef uint64_t pg_hash_t;
#endif

typedef struct pg_hashtable_t pg_hashtable_t;
typedef struct pg_hashtable_iterator_t pg_hashtable_iterator_t;
typedef void (*pg_hashtable_iterator_fn)(pg_hashtable_iterator_t* iterator, char* key, void* value);

static pg_hashtable_t* pg_hashtable_new(size_t capacity, size_t key_size, size_t value_size);
static void pg_hashtable_free(pg_hashtable_t* ht);
static void pg_hashtable_init_iterator(const pg_hashtable_t* ht, pg_hashtable_iterator_t* iterator);
static bool pg_hashtable_iterator_next(pg_hashtable_iterator_t* iterator, char** key, void** value);
static void pg_hashtable_put(pg_hashtable_t* ht, const char* key, const void* value);
static void* pg_hashtable_get(const pg_hashtable_t* ht, const char* key);

struct pg_hashtable_iterator_t
{
    const pg_hashtable_t* ht;
    size_t index;
    size_t count;
};

/*=============================================================================
 * Arena allocator
 *============================================================================*/

typedef struct pg_arena_t pg_arena_t;

static pg_arena_t* pg_arena_new(size_t size);
static void* pg_arena_alloc(pg_arena_t* arena, size_t size);
static void pg_arena_free(pg_arena_t* arena);

/*=============================================================================
 * Default Shader
 *============================================================================*/

static const sg_shader_desc* pg_default_shader_desc(sg_backend backend);
static int pg_default_uniformblock_slot(sg_shader_stage stage, const char* ub_name);

/*=============================================================================
 * GFX Public API implementation
 *============================================================================*/

static void* pg_malloc(size_t size, void* ctx)
{
    (void)ctx;
    return PICO_GFX_MALLOC(size);
}

static void pg_free(void* ptr, void* ctx)
{
    (void)ctx;
    PICO_GFX_FREE(ptr);
}

typedef struct pg_rect_t
{
    int x, y, width, height;
} pg_rect_t;

typedef struct pg_state_t
{
    sg_color       clear_color;
    pg_pipeline_t* pipeline;
    pg_rect_t      viewport;
    pg_rect_t      scissor;
    pg_shader_t*   shader;
    pg_vs_block_t  vs_block;
} pg_state_t;

struct pg_ctx_t
{
    int window_width;
    int window_height;
    bool indexed;
    sg_buffer buffer;
    sg_buffer index_buffer;
    bool pass_active;
    pg_pass_t* pass;
    pg_shader_t* default_shader;
    pg_pipeline_t* default_pipeline;
    pg_state_t state;
    pg_state_t state_stack[PICO_GFX_STACK_MAX_SIZE];
    int stack_size;
};

struct pg_pass_t
{
    sg_pass handle;
    pg_texture_t* texture;
};

struct pg_pipeline_t
{
    sg_pipeline handle;
    bool indexed;
    pg_shader_t* shader;
};

struct pg_shader_t
{
    const sg_shader_desc* desc;
    sg_shader handle;
    pg_shader_internal_t internal;
    pg_hashtable_t* uniform_blocks;
    pg_arena_t* arena;
};

typedef struct
{
    char       name[32]; //TODO: Define constant?
    pg_stage_t stage;
    void*      data;
    size_t     size;
    bool       dirty;
} pg_uniform_block_t;

struct pg_texture_t
{
    int width, height;
    bool target;
    sg_image handle;
    sg_image depth_handle;
};

struct pg_vbuffer_t
{
    sg_buffer handle;
    size_t count;
};

void pg_init()
{
    sg_setup(&(sg_desc)
    {
        .logger.func = pg_log_sg,
        .allocator =
        {
            .alloc = pg_malloc,
            .free = pg_free,
            .user_data = NULL,
        },
        .context.color_format = SG_PIXELFORMAT_RGBA8,
    });
}

void pg_shutdown()
{
    sg_shutdown();
}


void pg_set_identity(pg_ctx_t* ctx)
{
    ctx->state.vs_block = (pg_vs_block_t)
    {
        { 1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f
        },

        { 1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          0.0f, 0.0f, 0.0f, 1.0f
        }
    };

    pg_set_uniform_block(pg_get_default_shader(ctx), "pg_vs_block", &ctx->state.vs_block);
}

void pg_set_projection(pg_ctx_t* ctx, pg_mat4_t matrix)
{
    memcpy(ctx->state.vs_block.u_proj, matrix, sizeof(pg_mat4_t));
    pg_set_uniform_block(pg_get_default_shader(ctx), "pg_vs_block", &ctx->state.vs_block);
}

void pg_set_modelview(pg_ctx_t* ctx, pg_mat4_t matrix)
{
    memcpy(ctx->state.vs_block.u_mv, matrix, sizeof(pg_mat4_t));
    pg_set_uniform_block(pg_get_default_shader(ctx), "pg_vs_block", &ctx->state.vs_block);
}

pg_ctx_t* pg_create_context(int window_width, int window_height)
{
    pg_ctx_t* ctx = (pg_ctx_t*)PICO_GFX_MALLOC(sizeof(pg_ctx_t));

    memset(ctx, 0, sizeof(pg_ctx_t));

    ctx->window_width  = window_width;
    ctx->window_height = window_height;
    ctx->default_shader = pg_create_shader(pg_default);
    ctx->default_pipeline = pg_create_pipeline(PG_TRIANGLES, false, false, ctx->default_shader, NULL);

    pg_register_uniform_block(ctx->default_shader, PG_VS_STAGE, "pg_vs_block", sizeof(pg_vs_block_t));

    pg_reset_state(ctx);

    ctx->buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_VERTEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(pg_vertex_t),
        .usage = SG_USAGE_STREAM
    });

    PICO_GFX_ASSERT(sg_query_buffer_state(ctx->buffer) == SG_RESOURCESTATE_VALID);

    ctx->index_buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_INDEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(uint32_t),
        .usage = SG_USAGE_STREAM
    });

    PICO_GFX_ASSERT(sg_query_buffer_state(ctx->index_buffer) == SG_RESOURCESTATE_VALID);

    return ctx;
}

void pg_destroy_context(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);

    sg_destroy_buffer(ctx->buffer);
    sg_destroy_buffer(ctx->index_buffer);

    pg_destroy_pipeline(ctx->default_pipeline);
    pg_destroy_shader(ctx->default_shader);

    PICO_GFX_FREE(ctx);
}

pg_pass_t* pg_create_pass(pg_texture_t* texture)
{
    PICO_GFX_ASSERT(texture);
    PICO_GFX_ASSERT(texture->target);

    pg_pass_t* pass = (pg_pass_t*)PICO_GFX_MALLOC(sizeof(pg_pass_t));

    pass->handle = sg_make_pass(&(sg_pass_desc)
    {
        .color_attachments[0].image = texture->handle,
        .depth_stencil_attachment.image = texture->depth_handle
    });

    pass->texture = texture;

    return pass;
}

void pg_destroy_pass(pg_pass_t* pass)
{
    PICO_GFX_ASSERT(pass);
    sg_destroy_pass(pass->handle);
    PICO_GFX_FREE(pass);
}

void pg_begin_pass(pg_ctx_t* ctx, pg_pass_t* pass, bool clear)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(!ctx->pass_active);

    sg_pass_action pass_action;

    memset(&pass_action, 0, sizeof(sg_pass_action));

    if (clear)
    {
        sg_color color = ctx->state.clear_color;

        pass_action.colors[0] = (sg_color_attachment_action)
        {
            .load_action = SG_LOADACTION_CLEAR,
            .clear_value = color
        };
    }

    if (pass)
    {
        sg_begin_pass(pass->handle, &pass_action);
        ctx->pass = pass;
    }
    else
    {
        sg_begin_default_pass(&pass_action, ctx->window_width, ctx->window_height);
        //ctx->pass = NULL;
    }

    ctx->pass_active = true;
}

void pg_end_pass(pg_ctx_t* ctx)
{
    sg_end_pass();
    ctx->pass = NULL;
    ctx->pass_active = false;
}

void pg_flush(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);

    sg_commit();

    sg_destroy_buffer(ctx->buffer);

    ctx->buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_VERTEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(pg_vertex_t),
        .usage = SG_USAGE_STREAM
    });

    PICO_GFX_ASSERT(sg_query_buffer_state(ctx->buffer) == SG_RESOURCESTATE_VALID);

    sg_destroy_buffer(ctx->index_buffer);

    ctx->index_buffer = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_INDEXBUFFER,
        .size  = PICO_GFX_BUFFER_SIZE * sizeof(uint32_t),
        .usage = SG_USAGE_STREAM
    });

    PICO_GFX_ASSERT(sg_query_buffer_state(ctx->index_buffer) == SG_RESOURCESTATE_VALID);
}

void pg_push_state(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(ctx->stack_size < PICO_GFX_STACK_MAX_SIZE);

    ctx->state_stack[ctx->stack_size] = ctx->state;
    ctx->stack_size++;
}

void pg_pop_state(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(ctx->stack_size > 0);

    ctx->state = ctx->state_stack[ctx->stack_size - 1];
    ctx->stack_size--;

    pg_set_uniform_block(pg_get_default_shader(ctx), "pg_vs_block", &ctx->state.vs_block);
}

void pg_reset_state(pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);

    memset(&ctx->state, 0, sizeof(pg_state_t));

    pg_set_clear_color(ctx, 0.f, 0.f, 0.f, 1.f);
    pg_set_pipeline(ctx, ctx->default_pipeline);

    if (ctx->pass)
    {
        pg_texture_t* texture = ctx->pass->texture;
        pg_set_scissor(ctx, 0, 0, texture->width, texture->height);
        pg_set_viewport(ctx, 0, 0, texture->width, texture->height);
    }
    else
    {
        pg_set_scissor(ctx, 0, 0, ctx->window_width, ctx->window_height);
        pg_set_viewport(ctx, 0, 0, ctx->window_width, ctx->window_height);
    }

    pg_set_identity(ctx);
}

void pg_set_pipeline(pg_ctx_t* ctx, pg_pipeline_t* pipeline)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(pipeline);
    ctx->state.pipeline = pipeline;
}

pg_pipeline_t* pg_create_pipeline(pg_primitive_t primitive,
                                  bool target,
                                  bool indexed,
                                  pg_shader_t* shader,
                                  const pg_blend_mode_t* blend_mode)
{
    PICO_GFX_ASSERT(shader);

    sg_pipeline_desc desc;

    memset(&desc, 0, sizeof(sg_pipeline_desc));

    desc.layout.attrs[0] = (sg_vertex_attr_desc){ .format = SG_VERTEXFORMAT_FLOAT3, .offset = offsetof(pg_vertex_t, pos) },
    desc.layout.attrs[1] = (sg_vertex_attr_desc){ .format = SG_VERTEXFORMAT_FLOAT4, .offset = offsetof(pg_vertex_t, color) },
    desc.layout.attrs[2] = (sg_vertex_attr_desc){ .format = SG_VERTEXFORMAT_FLOAT2, .offset = offsetof(pg_vertex_t, uv) },

    desc.primitive_type = pg_map_primitive(primitive);

    if (blend_mode)
    {
        desc.colors[0].blend.enabled = true;
        desc.colors[0].blend.src_factor_rgb = pg_map_blend_factor(blend_mode->color_src);
        desc.colors[0].blend.dst_factor_rgb = pg_map_blend_factor(blend_mode->color_dst);
        desc.colors[0].blend.src_factor_alpha = pg_map_blend_factor(blend_mode->alpha_src);
        desc.colors[0].blend.dst_factor_alpha = pg_map_blend_factor(blend_mode->alpha_dst);
        desc.colors[0].blend.op_rgb = pg_map_blend_eq(blend_mode->color_eq);
        desc.colors[0].blend.op_alpha = pg_map_blend_eq(blend_mode->alpha_eq);
    }

    desc.colors[0].pixel_format = SG_PIXELFORMAT_RGBA8;

    if (indexed)
        desc.index_type = SG_INDEXTYPE_UINT32;
    else
        desc.index_type = SG_INDEXTYPE_NONE;

    if (target)
    {
        desc.depth.pixel_format = SG_PIXELFORMAT_DEPTH;
        desc.depth.write_enabled = true;
    }

    desc.shader = shader->handle;

    pg_pipeline_t* pipeline = (pg_pipeline_t*)PICO_GFX_MALLOC(sizeof(pg_pipeline_t));

    pipeline->handle = sg_make_pipeline(&desc);

    PICO_GFX_ASSERT(sg_query_pipeline_state(pipeline->handle) == SG_RESOURCESTATE_VALID);

    pipeline->indexed = indexed;
    pipeline->shader = shader;

    return pipeline;
}

void pg_destroy_pipeline(pg_pipeline_t* pipeline)
{
    sg_destroy_pipeline(pipeline->handle);
    PICO_GFX_FREE(pipeline);
}

void pg_set_clear_color(pg_ctx_t* ctx, float r, float g, float b, float a)
{
    ctx->state.clear_color = (sg_color){ r, g, b, a};
}

void pg_set_viewport(pg_ctx_t* ctx, int x, int y, int w, int h)
{
    ctx->state.viewport = (pg_rect_t){ x, y, w, h};
}

void pg_set_scissor(pg_ctx_t* ctx, int x, int y, int w, int h)
{
    ctx->state.scissor = (pg_rect_t){ x, y, w, h};
}

pg_shader_t* pg_create_shader_internal(pg_shader_internal_t internal)
{
    pg_shader_t* shader = (pg_shader_t*)PICO_GFX_MALLOC(sizeof(pg_shader_t));

    shader->internal = internal;

    shader->desc = internal.get_shader_desc(sg_query_backend());

    PICO_GFX_ASSERT(shader->desc);
    PICO_GFX_ASSERT(pg_str_equal(shader->desc->attrs[0].name, "a_pos"));
    PICO_GFX_ASSERT(pg_str_equal(shader->desc->attrs[1].name, "a_color"));
    PICO_GFX_ASSERT(pg_str_equal(shader->desc->attrs[2].name, "a_uv"));

    shader->handle = sg_make_shader(shader->desc);
    shader->uniform_blocks = pg_hashtable_new(8, 16, sizeof(pg_uniform_block_t)); // TODO: constants

    shader->arena = pg_arena_new(1024);

    return shader;
}

void pg_destroy_shader(pg_shader_t* shader)
{
    PICO_GFX_ASSERT(shader);
    sg_destroy_shader(shader->handle);
    pg_hashtable_free(shader->uniform_blocks);
    pg_arena_free(shader->arena);
    PICO_GFX_FREE(shader);
}

pg_shader_t* pg_get_default_shader(const pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    return ctx->default_shader;
}

pg_pipeline_t* pg_get_default_pipeline(const pg_ctx_t* ctx)
{
    PICO_GFX_ASSERT(ctx);
    return ctx->default_pipeline;
}

uint32_t pg_get_shader_id(const pg_shader_t* shader)
{
    PICO_GFX_ASSERT(shader);
    return shader->handle.id;
}

void pg_register_uniform_block(pg_shader_t* shader, pg_stage_t stage, const char* name, size_t size)
{
    PICO_GFX_ASSERT(shader);
    PICO_GFX_ASSERT(name);
    PICO_GFX_ASSERT(size > 0);

    pg_uniform_block_t block =
    {
        .stage = stage,
        .data  = pg_arena_alloc(shader->arena, size),
        .size  = size,
        .dirty = false
    };

    pg_str_copy(block.name, name, sizeof(block.name));

    pg_hashtable_put(shader->uniform_blocks, name, &block);
}

void pg_set_uniform_block(pg_shader_t* shader, const char* name, const void* data)
{
    PICO_GFX_ASSERT(shader);
    PICO_GFX_ASSERT(name);
    PICO_GFX_ASSERT(data);

    pg_uniform_block_t* block = pg_hashtable_get(shader->uniform_blocks, name);

    PICO_GFX_ASSERT(block);

    memcpy(block->data, data, block->size);
    block->dirty = true;
}

pg_texture_t* pg_create_texture(int width, int height,
                                const uint8_t* data, size_t size,
                                int mipmaps, bool smooth, bool repeat)
{
    PICO_GFX_ASSERT(width > 0);
    PICO_GFX_ASSERT(height > 0);
    PICO_GFX_ASSERT(data);
    PICO_GFX_ASSERT(size > 0);
    PICO_GFX_ASSERT(mipmaps >= 0);

    pg_texture_t* texture = (pg_texture_t*)PICO_GFX_MALLOC(sizeof(pg_texture_t));

    sg_image_desc desc;

    memset(&desc, 0, sizeof(sg_image_desc));

    desc.pixel_format = SG_PIXELFORMAT_RGBA8;

    desc.width  = texture->width  = width;
    desc.height = texture->height = height;

    desc.num_mipmaps = mipmaps;

    desc.min_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;
    desc.mag_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;

    desc.wrap_u = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;
    desc.wrap_v = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;

    desc.data.subimage[0][0] = (sg_range){ .ptr = data, .size = size };

    texture->target = false;
    texture->handle = sg_make_image(&desc);

    PICO_GFX_ASSERT(sg_query_image_state(texture->handle) == SG_RESOURCESTATE_VALID);

    return texture;
}

pg_texture_t* pg_create_render_texture(int width, int height,
                                       int mipmaps, bool smooth, bool repeat)
{
    PICO_GFX_ASSERT(width > 0);
    PICO_GFX_ASSERT(height > 0);
    PICO_GFX_ASSERT(mipmaps >= 0);

    pg_texture_t* texture = (pg_texture_t*)PICO_GFX_MALLOC(sizeof(pg_texture_t));

    sg_image_desc desc;

    memset(&desc, 0, sizeof(sg_image_desc));

    desc.render_target = true;
    desc.pixel_format = SG_PIXELFORMAT_RGBA8;

    desc.width  = texture->width  = width;
    desc.height = texture->height = height;

    desc.num_mipmaps = mipmaps;

    desc.min_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;
    desc.mag_filter = (smooth) ? SG_FILTER_LINEAR : SG_FILTER_NEAREST;

    desc.wrap_u = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;
    desc.wrap_v = (repeat) ? SG_WRAP_REPEAT : SG_WRAP_CLAMP_TO_EDGE;

    texture->handle = sg_make_image(&desc);
    texture->target = true;

    PICO_GFX_ASSERT(sg_query_image_state(texture->handle) == SG_RESOURCESTATE_VALID);

    desc.pixel_format = SG_PIXELFORMAT_DEPTH;
    texture->depth_handle = sg_make_image(&desc);

    PICO_GFX_ASSERT(sg_query_image_state(texture->depth_handle) == SG_RESOURCESTATE_VALID);

    return texture;
}

void pg_destroy_texture(pg_texture_t* texture)
{
    sg_destroy_image(texture->handle);
    PICO_GFX_FREE(texture);
}

/*TODO:
void pg_update_texture(pg_texture_t* texture, uint8_t* data, size_t size)
{

}*/

uint32_t pg_get_texture_id(const pg_texture_t* texture)
{
    PICO_GFX_ASSERT(texture);
    return texture->handle.id;
}

void pg_get_texture_size(const pg_texture_t* texture, int* width, int* height)
{
    PICO_GFX_ASSERT(texture);

    if (width)
        *width = texture->width;

    if (height)
        *height = texture->height;
}

static void pg_apply_uniforms(pg_shader_t* shader)
{
    PICO_GFX_ASSERT(shader);

    pg_hashtable_iterator_t iterator;
    pg_hashtable_init_iterator(shader->uniform_blocks, &iterator);

    char* key = NULL;
    void* value = NULL;

    while (pg_hashtable_iterator_next(&iterator, &key, &value))
    {
        pg_uniform_block_t* block = value;

        //if (block->dirty)
        //{
            sg_range range = { .ptr = block->data, .size = block->size };

            sg_shader_stage stage = pg_map_stage(block->stage);

            int slot = shader->internal.get_uniformblock_slot(stage, block->name);

            sg_apply_uniforms(stage, slot, &range);

            block->dirty = false;
        //}
    }
}

pg_vbuffer_t* pg_create_vbuffer(const pg_vertex_t* vertices, size_t count)
{
    PICO_GFX_ASSERT(vertices);
    PICO_GFX_ASSERT(count > 0);

    pg_vbuffer_t* buffer = (pg_vbuffer_t*)PICO_GFX_MALLOC(sizeof(pg_vbuffer_t));

    buffer->handle = sg_make_buffer(&(sg_buffer_desc)
    {
        .type  = SG_BUFFERTYPE_VERTEXBUFFER,
        .usage = SG_USAGE_IMMUTABLE,
        .data  = { .ptr = vertices, .size = count * sizeof(pg_vertex_t) }
    });

    PICO_GFX_ASSERT(sg_query_buffer_state(buffer->handle) == SG_RESOURCESTATE_VALID);

    buffer->count = count;

    return buffer;
}

void pg_destroy_vbuffer(pg_vbuffer_t* buffer)
{
    PICO_GFX_ASSERT(buffer);
    sg_destroy_buffer(buffer->handle);
    PICO_GFX_FREE(buffer);
}

static void pg_apply_view_state(const pg_ctx_t* ctx)
{
    const pg_rect_t* vp_rect = &ctx->state.viewport;
    sg_apply_viewport(vp_rect->x, vp_rect->y, vp_rect->width, vp_rect->height, true);

    const pg_rect_t* s_rect = &ctx->state.scissor;
    sg_apply_scissor_rect(s_rect->x, s_rect->y, s_rect->width, s_rect->height, true);
}

void pg_draw_vbuffer(const pg_ctx_t* ctx,
                     const pg_vbuffer_t* buffer,
                     size_t start, size_t count,
                     pg_texture_t* texture)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(buffer);
    PICO_GFX_ASSERT(ctx->pass_active);
    PICO_GFX_ASSERT(!ctx->state.pipeline->indexed);

    sg_bindings bindings;

    memset(&bindings, 0, sizeof(sg_bindings));

    if (texture)
        bindings.fs_images[0] = texture->handle;

    bindings.vertex_buffers[0] = buffer->handle;

    pg_apply_view_state(ctx);

    pg_pipeline_t* pipeline = ctx->state.pipeline;

    sg_apply_pipeline(pipeline->handle);
    sg_apply_bindings(&bindings);
    pg_apply_uniforms(pipeline->shader);

    PICO_GFX_ASSERT(start + count <= buffer->count);

    sg_draw(start, count, 1);
}

void pg_draw_array(pg_ctx_t* ctx,
                   const pg_vertex_t* vertices, size_t count,
                   pg_texture_t* texture)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(vertices);
    PICO_GFX_ASSERT(count > 0);
    PICO_GFX_ASSERT(ctx->pass_active);
    PICO_GFX_ASSERT(!ctx->state.pipeline->indexed);

    int offset = sg_append_buffer(ctx->buffer, &(sg_range) { .ptr = vertices, .size = count * sizeof(pg_vertex_t)});

    sg_bindings bindings;

    memset(&bindings, 0, sizeof(sg_bindings));

    if (texture)
        bindings.fs_images[0] = texture->handle;

    bindings.vertex_buffer_offsets[0] = offset;
    bindings.vertex_buffers[0] = ctx->buffer;

    pg_apply_view_state(ctx);

    pg_pipeline_t* pipeline = ctx->state.pipeline;

    sg_apply_pipeline(pipeline->handle);
    sg_apply_bindings(&bindings);
    pg_apply_uniforms(pipeline->shader);

    sg_draw(0, count, 1);
}

void pg_draw_indexed_array(pg_ctx_t* ctx,
                           const pg_vertex_t* vertices, size_t vertex_count,
                           const uint32_t* indices, size_t index_count,
                           pg_texture_t* texture)
{
    PICO_GFX_ASSERT(ctx);
    PICO_GFX_ASSERT(vertices);
    PICO_GFX_ASSERT(vertex_count > 0);
    PICO_GFX_ASSERT(indices);
    PICO_GFX_ASSERT(index_count > 0);
    PICO_GFX_ASSERT(ctx->pass_active);
    PICO_GFX_ASSERT(ctx->state.pipeline->indexed);

    int vertex_offset = sg_append_buffer(ctx->buffer, &(sg_range)
    {
        .ptr = vertices, .size = vertex_count * sizeof(pg_vertex_t)
    });

    int index_offset = sg_append_buffer(ctx->index_buffer, &(sg_range)
    {
        .ptr = indices, .size = index_count * sizeof(uint32_t)
    });

    sg_bindings bindings;

    memset(&bindings, 0, sizeof(sg_bindings));

    if (texture)
        bindings.fs_images[0] = texture->handle;

    bindings.vertex_buffer_offsets[0] = vertex_offset;
    bindings.index_buffer_offset = index_offset;
    bindings.vertex_buffers[0] = ctx->buffer;
    bindings.index_buffer = ctx->index_buffer;

    pg_apply_view_state(ctx);

    pg_pipeline_t* pipeline = ctx->state.pipeline;

    sg_apply_pipeline(pipeline->handle);
    sg_apply_bindings(&bindings);
    pg_apply_uniforms(pipeline->shader);

    sg_draw(0, index_count, 1);
}

/*==============================================================================
 * GFX Static Functions
 *============================================================================*/

static sg_primitive_type pg_map_primitive(pg_primitive_t primitive)
{
    if (primitive == PG_DEFAULT_PRIMITIVE)
        primitive = PG_TRIANGLES;

    switch (primitive)
    {
        case PG_POINTS:         return SG_PRIMITIVETYPE_POINTS;
        case PG_LINES:          return SG_PRIMITIVETYPE_LINES;
        case PG_LINE_STRIP:     return SG_PRIMITIVETYPE_LINE_STRIP;
        case PG_TRIANGLES:      return SG_PRIMITIVETYPE_TRIANGLES;
        case PG_TRIANGLE_STRIP: return SG_PRIMITIVETYPE_TRIANGLE_STRIP;
        default: PICO_GFX_ASSERT(false);
    }
}

static sg_blend_factor pg_map_blend_factor(pg_blend_factor_t factor)
{
    if (factor == PG_DEFAULT_BLEND_FACTOR)
        factor = PG_ONE;

    switch (factor)
    {
        case PG_ZERO:                return SG_BLENDFACTOR_ZERO;
        case PG_ONE:                 return SG_BLENDFACTOR_ONE;
        case PG_SRC_COLOR:           return SG_BLENDFACTOR_SRC_COLOR;
        case PG_ONE_MINUS_SRC_COLOR: return SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR;
        case PG_DST_COLOR:           return SG_BLENDFACTOR_DST_COLOR;
        case PG_ONE_MINUS_DST_COLOR: return SG_BLENDFACTOR_ZERO;
        case PG_SRC_ALPHA:           return SG_BLENDFACTOR_SRC_ALPHA;
        case PG_ONE_MINUS_SRC_ALPHA: return SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
        case PG_DST_ALPHA:           return SG_BLENDFACTOR_DST_ALPHA;
        case PG_ONE_MINUS_DST_ALPHA: return SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA;
        default: PICO_GFX_ASSERT(false);
    }
}

static sg_blend_op pg_map_blend_eq(pg_blend_eq_t eq)
{
    if (eq == PG_DEFAULT_BLEND_EQ)
        eq = PG_ADD;

    switch (eq)
    {
        case PG_ADD:              return SG_BLENDOP_ADD;
        case PG_SUBTRACT:         return SG_BLENDOP_SUBTRACT;
        case PG_REVERSE_SUBTRACT: return SG_BLENDOP_REVERSE_SUBTRACT;
        default: PICO_GFX_ASSERT(false);
    }
}

static sg_shader_stage pg_map_stage(pg_stage_t stage)
{
    switch (stage)
    {
        case PG_VS_STAGE: return SG_SHADERSTAGE_VS;
        case PG_FS_STAGE: return SG_SHADERSTAGE_FS;
        default: PICO_GFX_ASSERT(false);
    }
}

static void pg_log(const char* fmt, ...)
{
    PICO_GFX_ASSERT(fmt);

    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    printf("\n");
    fflush(stdout);
}

static void pg_log_sg(const char* tag,                // e.g. 'sg'
                      uint32_t log_level,             // 0=panic, 1=error, 2=warn, 3=info
                      uint32_t log_item_id,           // SG_LOGITEM_*
                      const char* message_or_null,    // a message string, may be nullptr in release mode
                      uint32_t line_nr,               // line number in sokol_gfx.h
                      const char* filename_or_null,   // source filename, may be nullptr in release mode
                      void* user_data)
{
    (void)log_item_id;
    (void)user_data;

    static const char* level[] =
    {
        "Panic",
        "Error",
        "Warn",
        "Info",
    };

    // FIXME: Handle non-debug case

    if (message_or_null && !filename_or_null)
    {
        PICO_GFX_LOG("Tag: %s, Level: %s, Message: %s", tag, level[log_level], message_or_null);
    }

    if (!message_or_null && filename_or_null)
    {
        PICO_GFX_LOG("Tag: %s, Level: %s, File: %s, Line: %d", tag, level[log_level], filename_or_null, line_nr);
    }

    if (message_or_null && filename_or_null)
    {
        PICO_GFX_LOG("Tag: %s, Level: %s, File: %s, Line: %d, Message: %s", tag, level[log_level], filename_or_null, line_nr, message_or_null);
    }
}

/*==============================================================================
 * Hashtable Data structures
 *============================================================================*/

typedef struct
{
    bool in_use;
    pg_hash_t hash;
    char* key;
    void* value;
} pg_hashtable_entry_t;

struct pg_hashtable_t
{
    size_t capacity;
    size_t size;

    pg_hashtable_entry_t* entries;

    size_t key_size;
    char* keys;

    size_t value_size;
    void* values;
};

/*==============================================================================
 * Hashtable Internal Declarations
 *============================================================================*/

static size_t pg_hashtable_compute_hash(const pg_hashtable_t* ht,
                                        const char* key);

static bool pg_hashtable_key_equal(const pg_hashtable_t* ht,
                                   const char* key1,
                                   const char* key2);

static void pg_hashtable_copy_value(pg_hashtable_t* ht,
                                    pg_hashtable_entry_t* entry,
                                    const void* value);

static void pg_hashtable_swap_size(size_t* a, size_t* b);
static void pg_hashtable_swap_ptr(void** a, void** b);
static void pg_hashtable_swap(pg_hashtable_t* ht1, pg_hashtable_t* ht2);
static void pg_hashtable_rehash(pg_hashtable_t* ht);

/*==============================================================================
 * Hashtable Public Implementation
 *============================================================================*/

static pg_hashtable_t* pg_hashtable_new(size_t capacity,
                                        size_t key_size,
                                        size_t value_size)
{
    bool power_of_two = (0 == (capacity & (capacity - 1)));

    PICO_GFX_ASSERT(capacity > 2 && power_of_two);
    PICO_GFX_ASSERT(key_size > 0);
    PICO_GFX_ASSERT(value_size > 0);

    if (capacity <= 2 || !power_of_two)
        return NULL;

    if (0 == key_size || 0 == value_size)
        return NULL;

    pg_hashtable_t* ht = PICO_GFX_MALLOC(sizeof(pg_hashtable_t));

    if (!ht)
        return NULL;

    ht->capacity = capacity;
    ht->size = 0;
    ht->key_size = key_size;
    ht->value_size = value_size;

    ht->entries = PICO_GFX_MALLOC(capacity * sizeof(pg_hashtable_entry_t));

    if (!ht->entries)
    {
        PICO_GFX_FREE(ht);
        return NULL;
    }

    ht->keys = PICO_GFX_MALLOC(capacity * key_size);

    if (!ht->keys)
    {
        PICO_GFX_FREE(ht->entries);
        PICO_GFX_FREE(ht);

        return NULL;
    }

    if (value_size > 0)
    {
        ht->values = PICO_GFX_MALLOC(capacity * value_size);

        if (!ht->values)
        {
            PICO_GFX_FREE(ht->entries);
            PICO_GFX_FREE(ht->keys);
            PICO_GFX_FREE(ht);
            return NULL;
        }
    }
    else
    {
        ht->values = NULL;
    }

    for (size_t i = 0; i < capacity; i++)
    {
        pg_hashtable_entry_t* entry = &ht->entries[i];
        entry->in_use = false;
        entry->hash = 0;
        entry->key = (char*)ht->keys + i * key_size;

        if (value_size > 0)
            entry->value = (char*)ht->values + i * value_size;
        else
            entry->value = NULL;
    }

    return ht;
}

static void pg_hashtable_free(pg_hashtable_t* ht)
{
    PICO_GFX_ASSERT(NULL != ht);

    PICO_GFX_FREE(ht->entries);
    PICO_GFX_FREE(ht->keys);

    if (ht->value_size > 0)
        PICO_GFX_FREE(ht->values);

    PICO_GFX_FREE(ht);
}

static void pg_hashtable_init_iterator(const pg_hashtable_t* ht,
                                       pg_hashtable_iterator_t* iterator)
{
    PICO_GFX_ASSERT(NULL != ht);
    iterator->ht = ht;
    iterator->index = 0;
    iterator->count = 0;
}

static bool pg_hashtable_iterator_next(pg_hashtable_iterator_t* iterator,
                                       char** key, void** value)
{
    PICO_GFX_ASSERT(NULL != iterator);

    const pg_hashtable_t* ht = iterator->ht;

    if (iterator->count >= ht->capacity)
        return false;

    while (iterator->index < ht->capacity)
    {
        pg_hashtable_entry_t* entry = &ht->entries[iterator->index];

        if (entry->in_use)
        {
            if (key)
                *key = entry->key;

            if (value)
                *value = entry->value;

            iterator->count++;
            iterator->index++;

            return true;
        }

        iterator->index++;
    }

    return false;
}

static void pg_hashtable_put(pg_hashtable_t* ht,
                             const char* key,
                             const void* value)
{
    PICO_GFX_ASSERT(NULL != ht);

    if (ht->size == ht->capacity)
    {
        pg_hashtable_rehash(ht);
        PICO_GFX_ASSERT(ht->capacity > 0);
    }

    pg_hash_t hash = pg_hashtable_compute_hash(ht, key);
    size_t start_index = hash % ht->capacity;
    size_t index = start_index;

    do
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use && entry->hash == hash && pg_hashtable_key_equal(ht, key, entry->key))
        {
            pg_hashtable_copy_value(ht, entry, value);
            break;
        }

        if (!entry->in_use)
        {
            entry->in_use = true;
            entry->hash = hash;

            memcpy(entry->key, key, ht->key_size);
            pg_hashtable_copy_value(ht, entry, value);

            ht->size++;

            break;
        }

        index = (index + 1) % ht->capacity;

    } while (index != start_index);

    start_index = index;
    index = (index + 1) % ht->capacity;

    while (index != start_index)
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use &&
            entry->hash == hash &&
            pg_hashtable_key_equal(ht, key, entry->key))
        {
            entry->in_use = false;
            ht->size--;
            return;
        }

        index = (index + 1) % ht->capacity;
    }
}

static void* pg_hashtable_get(const pg_hashtable_t* ht, const char* key)
{
    PICO_GFX_ASSERT(NULL != ht);

    pg_hash_t hash = pg_hashtable_compute_hash(ht, key);
    size_t start_index = hash % ht->capacity;
    size_t index = start_index;

    do
    {
        pg_hashtable_entry_t* entry = &ht->entries[index];

        if (entry->in_use &&
            entry->hash == hash &&
            pg_hashtable_key_equal(ht, key, entry->key))
        {
            return entry->value;
        }

        index = (index + 1) % ht->capacity;

    } while (index != start_index);

    return NULL;
}

/*==============================================================================
 * Hashtable Internal API
 *============================================================================*/

static bool pg_hashtable_key_equal(const pg_hashtable_t* ht,
                                   const char* key1,
                                   const char* key2)
{
    return 0 == strncmp(key1, key2, ht->key_size);
}

static void pg_hashtable_copy_value(pg_hashtable_t* ht,
                                    pg_hashtable_entry_t* entry,
                                    const void* value)
{
    memcpy(entry->value, value, ht->value_size);
}

static void pg_hashtable_swap_size(size_t* a, size_t* b)
{
    size_t tmp = *a;
    *a = *b;
    *b = tmp;
}

static void pg_hashtable_swap_ptr(void** a, void** b)
{
    void* tmp = *a;
    *a = *b;
    *b = tmp;
}

static void pg_hashtable_swap(pg_hashtable_t* ht1, pg_hashtable_t* ht2)
{
    pg_hashtable_swap_size(&ht1->capacity, &ht2->capacity);
    pg_hashtable_swap_size(&ht1->size, &ht2->size);

    pg_hashtable_swap_ptr((void**)&ht1->entries, (void**)&ht2->entries);

    pg_hashtable_swap_size(&ht1->key_size, &ht2->key_size);
    pg_hashtable_swap_ptr((void**)&ht1->keys, (void**)&ht2->keys);

    pg_hashtable_swap_size(&ht1->value_size, &ht2->value_size);
    pg_hashtable_swap_ptr(&ht1->values, &ht2->values);
}

static void pg_hashtable_rehash(pg_hashtable_t* ht)
{
    pg_hashtable_t* new_ht = pg_hashtable_new(ht->capacity * 2,
                                              ht->key_size,
                                              ht->size);

    pg_hashtable_iterator_t iterator;
    pg_hashtable_init_iterator(ht, &iterator);

    char* key;
    void* value;

    while (pg_hashtable_iterator_next(&iterator, &key, &value))
    {
        pg_hashtable_put(new_ht, key, value);
    }

    pg_hashtable_swap(ht, new_ht);

    pg_hashtable_free(new_ht);
}

/*==============================================================================
 * Hash Functions
 *============================================================================*/

static size_t pg_hashtable_compute_hash(const pg_hashtable_t* ht, const char* key)
{

#ifdef PICO_GFX_32BIT
    static const uint32_t offset_basis = 0x811C9DC5;
    static const uint32_t prime = 0x1000193;
#else
    static const uint64_t offset_basis = 0xCBF29CE484222325;
    static const uint64_t prime = 0x100000001B3;
#endif

    const char* data = key;

    pg_hash_t hash = offset_basis;

    for (size_t i = 0; i < ht->key_size; i++) {
        hash ^= (pg_hash_t)data[i];
        hash *= prime;
    }

    return hash;
}

/*==============================================================================
 * Arena allocator
 *============================================================================*/

struct pg_arena_t
{
    size_t capacity;
    size_t size;
    void*  block;
};

static pg_arena_t* pg_arena_new(size_t size)
{
    PICO_GFX_ASSERT(size > 0);

    pg_arena_t* arena = PICO_GFX_MALLOC(sizeof(pg_arena_t));

    memset(arena, 0, sizeof(pg_arena_t));

    arena->capacity = size * 2;
    arena->block = PICO_GFX_MALLOC(arena->capacity);
    arena->size = size;

    return arena;
}

static void* pg_arena_alloc(pg_arena_t* arena, size_t size)
{
    if (arena->size + size > arena->capacity)
    {
        while (arena->size + size >= arena->capacity)
        {
            arena->capacity *= 2;
        }

        arena->block = PICO_GFX_REALLOC(arena->block, arena->capacity);
    }

    void* mem = (char*)arena->block + arena->size;

    arena->size += size;

    return mem;
}

static void pg_arena_free(pg_arena_t* arena)
{
    PICO_GFX_FREE(arena->block);
    PICO_GFX_FREE(arena);
}

/*==============================================================================
 * Default Shader Internals
 *============================================================================*/
#if defined(SOKOL_GLCORE33)
/*
    #version 330

    uniform vec4 pg_vs_block[8];
    layout(location = 0) in vec3 a_pos;
    out vec4 color;
    layout(location = 1) in vec4 a_color;
    out vec2 uv;
    layout(location = 2) in vec2 a_uv;

    void main()
    {
        gl_Position = (mat4(pg_vs_block[0], pg_vs_block[1], pg_vs_block[2], pg_vs_block[3]) * mat4(pg_vs_block[4], pg_vs_block[5], pg_vs_block[6], pg_vs_block[7])) * vec4(a_pos, 1.0);
        color = a_color;
        uv = a_uv;
        gl_Position.y = -gl_Position.y;
    }

*/
static const char vs_source_glsl330[452] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x33,0x30,0x0a,0x0a,0x75,0x6e,
    0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x70,0x67,0x5f,0x76,0x73,
    0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x38,0x5d,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,
    0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,
    0x69,0x6e,0x20,0x76,0x65,0x63,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x3b,0x0a,0x6f,
    0x75,0x74,0x20,0x76,0x65,0x63,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x6c,
    0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x31,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x34,0x20,0x61,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x3b,0x0a,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,
    0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,
    0x6e,0x20,0x3d,0x20,0x32,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x32,0x20,0x61,
    0x5f,0x75,0x76,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,
    0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,
    0x69,0x6f,0x6e,0x20,0x3d,0x20,0x28,0x6d,0x61,0x74,0x34,0x28,0x70,0x67,0x5f,0x76,
    0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x30,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,
    0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x31,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,
    0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x32,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,
    0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x33,0x5d,0x29,0x20,0x2a,0x20,0x6d,0x61,
    0x74,0x34,0x28,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x34,
    0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x35,
    0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x36,
    0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x37,
    0x5d,0x29,0x29,0x20,0x2a,0x20,0x76,0x65,0x63,0x34,0x28,0x61,0x5f,0x70,0x6f,0x73,
    0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,
    0x72,0x20,0x3d,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x75,0x76,0x20,0x3d,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,
    0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x2e,0x79,0x20,0x3d,0x20,
    0x2d,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x2e,0x79,0x3b,0x0a,
    0x7d,0x0a,0x0a,0x00,
};
/*
    #version 330

    uniform sampler2D u_tex;

    layout(location = 0) out vec4 frag_color;
    in vec2 uv;
    in vec4 color;

    void main()
    {
        frag_color = texture(u_tex, uv) * color;
    }

*/
static const char fs_source_glsl330[173] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x33,0x30,0x0a,0x0a,0x75,0x6e,
    0x69,0x66,0x6f,0x72,0x6d,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x32,0x44,0x20,
    0x75,0x5f,0x74,0x65,0x78,0x3b,0x0a,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,
    0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x6f,0x75,0x74,
    0x20,0x76,0x65,0x63,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x69,0x6e,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,0x0a,0x69,0x6e,
    0x20,0x76,0x65,0x63,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,0x6f,
    0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x2c,0x20,0x75,0x76,0x29,0x20,
    0x2a,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_GLCORE33 */
#if defined(SOKOL_GLES3)
/*
    #version 300 es

    uniform vec4 pg_vs_block[8];
    layout(location = 0) in vec3 a_pos;
    out vec4 color;
    layout(location = 1) in vec4 a_color;
    out vec2 uv;
    layout(location = 2) in vec2 a_uv;

    void main()
    {
        gl_Position = (mat4(pg_vs_block[0], pg_vs_block[1], pg_vs_block[2], pg_vs_block[3]) * mat4(pg_vs_block[4], pg_vs_block[5], pg_vs_block[6], pg_vs_block[7])) * vec4(a_pos, 1.0);
        color = a_color;
        uv = a_uv;
        gl_Position.y = -gl_Position.y;
    }

*/
static const char vs_source_glsl300es[455] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x30,0x30,0x20,0x65,0x73,0x0a,
    0x0a,0x75,0x6e,0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x70,0x67,
    0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x38,0x5d,0x3b,0x0a,0x6c,0x61,
    0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,
    0x30,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,
    0x3b,0x0a,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,
    0x6e,0x20,0x3d,0x20,0x31,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x34,0x20,0x61,
    0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x32,
    0x20,0x75,0x76,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,
    0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x32,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,
    0x32,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,
    0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,
    0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x28,0x6d,0x61,0x74,0x34,0x28,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x30,0x5d,0x2c,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x31,0x5d,0x2c,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x32,0x5d,0x2c,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x5b,0x33,0x5d,0x29,0x20,0x2a,
    0x20,0x6d,0x61,0x74,0x34,0x28,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,
    0x6b,0x5b,0x34,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,
    0x6b,0x5b,0x35,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,
    0x6b,0x5b,0x36,0x5d,0x2c,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,
    0x6b,0x5b,0x37,0x5d,0x29,0x29,0x20,0x2a,0x20,0x76,0x65,0x63,0x34,0x28,0x61,0x5f,
    0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x63,
    0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x75,0x76,0x20,0x3d,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x20,
    0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x2e,0x79,
    0x20,0x3d,0x20,0x2d,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x2e,
    0x79,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #version 300 es
    precision mediump float;
    precision highp int;

    uniform highp sampler2D u_tex;

    layout(location = 0) out highp vec4 frag_color;
    in highp vec2 uv;
    in highp vec4 color;

    void main()
    {
        frag_color = texture(u_tex, uv) * color;
    }

*/
static const char fs_source_glsl300es[246] = {
    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x30,0x30,0x20,0x65,0x73,0x0a,
    0x70,0x72,0x65,0x63,0x69,0x73,0x69,0x6f,0x6e,0x20,0x6d,0x65,0x64,0x69,0x75,0x6d,
    0x70,0x20,0x66,0x6c,0x6f,0x61,0x74,0x3b,0x0a,0x70,0x72,0x65,0x63,0x69,0x73,0x69,
    0x6f,0x6e,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x69,0x6e,0x74,0x3b,0x0a,0x0a,0x75,
    0x6e,0x69,0x66,0x6f,0x72,0x6d,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x73,0x61,0x6d,
    0x70,0x6c,0x65,0x72,0x32,0x44,0x20,0x75,0x5f,0x74,0x65,0x78,0x3b,0x0a,0x0a,0x6c,
    0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x30,0x29,0x20,0x6f,0x75,0x74,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x76,0x65,
    0x63,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x69,
    0x6e,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,
    0x0a,0x69,0x6e,0x20,0x68,0x69,0x67,0x68,0x70,0x20,0x76,0x65,0x63,0x34,0x20,0x63,
    0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,
    0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x75,0x5f,
    0x74,0x65,0x78,0x2c,0x20,0x75,0x76,0x29,0x20,0x2a,0x20,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_GLES3 */
#if defined(SOKOL_D3D11)
/*
    cbuffer pg_vs_block : register(b0)
    {
        row_major float4x4 _21_u_proj : packoffset(c0);
        row_major float4x4 _21_u_mv : packoffset(c4);
    };


    static float4 gl_Position;
    static float3 a_pos;
    static float4 color;
    static float4 a_color;
    static float2 uv;
    static float2 a_uv;

    struct SPIRV_Cross_Input
    {
        float3 a_pos : TEXCOORD0;
        float4 a_color : TEXCOORD1;
        float2 a_uv : TEXCOORD2;
    };

    struct SPIRV_Cross_Output
    {
        float4 color : TEXCOORD0;
        float2 uv : TEXCOORD1;
        float4 gl_Position : SV_Position;
    };

    void vert_main()
    {
        gl_Position = mul(float4(a_pos, 1.0f), mul(_21_u_mv, _21_u_proj));
        color = a_color;
        uv = a_uv;
    }

    SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
    {
        a_pos = stage_input.a_pos;
        a_color = stage_input.a_color;
        a_uv = stage_input.a_uv;
        vert_main();
        SPIRV_Cross_Output stage_output;
        stage_output.gl_Position = gl_Position;
        stage_output.color = color;
        stage_output.uv = uv;
        return stage_output;
    }
*/
static const char vs_source_hlsl5[989] = {
    0x63,0x62,0x75,0x66,0x66,0x65,0x72,0x20,0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,
    0x6f,0x63,0x6b,0x20,0x3a,0x20,0x72,0x65,0x67,0x69,0x73,0x74,0x65,0x72,0x28,0x62,
    0x30,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x72,0x6f,0x77,0x5f,0x6d,0x61,0x6a,
    0x6f,0x72,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x5f,0x32,0x31,0x5f,
    0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x3a,0x20,0x70,0x61,0x63,0x6b,0x6f,0x66,0x66,
    0x73,0x65,0x74,0x28,0x63,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x6f,0x77,
    0x5f,0x6d,0x61,0x6a,0x6f,0x72,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,
    0x5f,0x32,0x31,0x5f,0x75,0x5f,0x6d,0x76,0x20,0x3a,0x20,0x70,0x61,0x63,0x6b,0x6f,
    0x66,0x66,0x73,0x65,0x74,0x28,0x63,0x34,0x29,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x0a,
    0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,
    0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,0x73,0x74,0x61,0x74,0x69,
    0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x3b,0x0a,
    0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,
    0x6c,0x6f,0x72,0x3b,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,
    0x74,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x73,0x74,0x61,0x74,
    0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x3b,0x0a,0x73,0x74,
    0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,0x5f,0x75,0x76,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,
    0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,0x70,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,
    0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,0x3a,
    0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x30,0x3b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3a,
    0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x31,0x3b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,0x5f,0x75,0x76,0x20,0x3a,0x20,0x54,0x45,
    0x58,0x43,0x4f,0x4f,0x52,0x44,0x32,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,
    0x75,0x63,0x74,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,
    0x4f,0x75,0x74,0x70,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,
    0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,
    0x4f,0x4f,0x52,0x44,0x30,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x31,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,
    0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3a,0x20,0x53,0x56,0x5f,0x50,0x6f,
    0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,
    0x20,0x76,0x65,0x72,0x74,0x5f,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,
    0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,
    0x20,0x6d,0x75,0x6c,0x28,0x66,0x6c,0x6f,0x61,0x74,0x34,0x28,0x61,0x5f,0x70,0x6f,
    0x73,0x2c,0x20,0x31,0x2e,0x30,0x66,0x29,0x2c,0x20,0x6d,0x75,0x6c,0x28,0x5f,0x32,
    0x31,0x5f,0x75,0x5f,0x6d,0x76,0x2c,0x20,0x5f,0x32,0x31,0x5f,0x75,0x5f,0x70,0x72,
    0x6f,0x6a,0x29,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,
    0x3d,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x75,
    0x76,0x20,0x3d,0x20,0x61,0x5f,0x75,0x76,0x3b,0x0a,0x7d,0x0a,0x0a,0x53,0x50,0x49,
    0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x20,
    0x6d,0x61,0x69,0x6e,0x28,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,
    0x5f,0x49,0x6e,0x70,0x75,0x74,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,
    0x75,0x74,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,
    0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x61,0x5f,
    0x70,0x6f,0x73,0x3b,0x0a,0x20,0x20,0x20,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x61,
    0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x61,0x5f,0x75,0x76,
    0x20,0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x61,
    0x5f,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x76,0x65,0x72,0x74,0x5f,0x6d,0x61,
    0x69,0x6e,0x28,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,
    0x43,0x72,0x6f,0x73,0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x20,0x73,0x74,0x61,
    0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x3b,0x0a,0x20,0x20,0x20,0x20,0x73,
    0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x2e,0x67,0x6c,0x5f,0x50,
    0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,
    0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,0x20,0x20,0x20,0x20,0x73,0x74,0x61,0x67,0x65,
    0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x2e,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x73,0x74,0x61,0x67,0x65,
    0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x75,0x76,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x73,0x74,0x61,0x67,
    0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x3b,0x0a,0x7d,0x0a,0x00,
};
/*
    Texture2D<float4> u_tex : register(t0);
    SamplerState _u_tex_sampler : register(s0);

    static float4 frag_color;
    static float2 uv;
    static float4 color;

    struct SPIRV_Cross_Input
    {
        float4 color : TEXCOORD0;
        float2 uv : TEXCOORD1;
    };

    struct SPIRV_Cross_Output
    {
        float4 frag_color : SV_Target0;
    };

    void frag_main()
    {
        frag_color = u_tex.Sample(_u_tex_sampler, uv) * color;
    }

    SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
    {
        uv = stage_input.uv;
        color = stage_input.color;
        frag_main();
        SPIRV_Cross_Output stage_output;
        stage_output.frag_color = frag_color;
        return stage_output;
    }
*/
static const char fs_source_hlsl5[625] = {
    0x54,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x44,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x34,
    0x3e,0x20,0x75,0x5f,0x74,0x65,0x78,0x20,0x3a,0x20,0x72,0x65,0x67,0x69,0x73,0x74,
    0x65,0x72,0x28,0x74,0x30,0x29,0x3b,0x0a,0x53,0x61,0x6d,0x70,0x6c,0x65,0x72,0x53,
    0x74,0x61,0x74,0x65,0x20,0x5f,0x75,0x5f,0x74,0x65,0x78,0x5f,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x72,0x20,0x3a,0x20,0x72,0x65,0x67,0x69,0x73,0x74,0x65,0x72,0x28,0x73,
    0x30,0x29,0x3b,0x0a,0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,
    0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x73,
    0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x3b,
    0x0a,0x73,0x74,0x61,0x74,0x69,0x63,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,
    0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x53,0x50,
    0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,0x70,0x75,0x74,0x0a,
    0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,
    0x6f,0x72,0x20,0x3a,0x20,0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x30,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x20,0x3a,0x20,
    0x54,0x45,0x58,0x43,0x4f,0x4f,0x52,0x44,0x31,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,
    0x74,0x72,0x75,0x63,0x74,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,
    0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x3a,0x20,0x53,0x56,0x5f,0x54,0x61,0x72,0x67,0x65,0x74,0x30,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x66,0x72,0x61,0x67,0x5f,0x6d,0x61,0x69,
    0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,
    0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x53,0x61,0x6d,
    0x70,0x6c,0x65,0x28,0x5f,0x75,0x5f,0x74,0x65,0x78,0x5f,0x73,0x61,0x6d,0x70,0x6c,
    0x65,0x72,0x2c,0x20,0x75,0x76,0x29,0x20,0x2a,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,
    0x0a,0x7d,0x0a,0x0a,0x53,0x50,0x49,0x52,0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,
    0x4f,0x75,0x74,0x70,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x28,0x53,0x50,0x49,0x52,
    0x56,0x5f,0x43,0x72,0x6f,0x73,0x73,0x5f,0x49,0x6e,0x70,0x75,0x74,0x20,0x73,0x74,
    0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,
    0x20,0x75,0x76,0x20,0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,
    0x74,0x2e,0x75,0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,
    0x3d,0x20,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x70,0x75,0x74,0x2e,0x63,0x6f,
    0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x6d,0x61,
    0x69,0x6e,0x28,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x53,0x50,0x49,0x52,0x56,0x5f,
    0x43,0x72,0x6f,0x73,0x73,0x5f,0x4f,0x75,0x74,0x70,0x75,0x74,0x20,0x73,0x74,0x61,
    0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x3b,0x0a,0x20,0x20,0x20,0x20,0x73,
    0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,
    0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,
    0x73,0x74,0x61,0x67,0x65,0x5f,0x6f,0x75,0x74,0x70,0x75,0x74,0x3b,0x0a,0x7d,0x0a,
    0x00,
};
#endif /* SOKOL_D3D11 */
#if defined(SOKOL_METAL)
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct pg_vs_block
    {
        float4x4 u_proj;
        float4x4 u_mv;
    };

    struct main0_out
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 a_pos [[attribute(0)]];
        float4 a_color [[attribute(1)]];
        float2 a_uv [[attribute(2)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant pg_vs_block& _21 [[buffer(0)]])
    {
        main0_out out = {};
        out.gl_Position = (_21.u_proj * _21.u_mv) * float4(in.a_pos, 1.0);
        out.color = in.a_color;
        out.uv = in.a_uv;
        return out;
    }

*/
static const char vs_source_metal_macos[647] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x0a,0x7b,0x0a,0x20,0x20,0x20,
    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x75,0x5f,0x70,0x72,0x6f,0x6a,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x75,
    0x5f,0x6d,0x76,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,
    0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,
    0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,
    0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,
    0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,
    0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,
    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,
    0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,
    0x62,0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,
    0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,0x5f,0x75,0x76,0x20,
    0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,
    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,0x74,0x65,0x78,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,
    0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,
    0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x26,0x20,0x5f,0x32,0x31,
    0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,
    0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,
    0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,
    0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,
    0x28,0x5f,0x32,0x31,0x2e,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x2a,0x20,0x5f,0x32,
    0x31,0x2e,0x75,0x5f,0x6d,0x76,0x29,0x20,0x2a,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,
    0x28,0x69,0x6e,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,
    0x20,0x69,0x6e,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x61,0x5f,0x75,
    0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,
    0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 frag_color [[color(0)]];
    };

    struct main0_in
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.frag_color = u_tex.sample(u_texSmplr, in.uv) * in.color;
        return out;
    }

*/
static const char fs_source_metal_macos[454] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,
    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,
    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,
    0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,
    0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,
    0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,
    0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x3e,0x20,0x75,0x5f,
    0x74,0x65,0x78,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x30,0x29,
    0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,0x75,0x5f,0x74,0x65,
    0x78,0x53,0x6d,0x70,0x6c,0x72,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,
    0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x53,0x6d,0x70,0x6c,0x72,0x2c,0x20,0x69,
    0x6e,0x2e,0x75,0x76,0x29,0x20,0x2a,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_METAL */
#if defined(SOKOL_METAL)
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct pg_vs_block
    {
        float4x4 u_proj;
        float4x4 u_mv;
    };

    struct main0_out
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 a_pos [[attribute(0)]];
        float4 a_color [[attribute(1)]];
        float2 a_uv [[attribute(2)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant pg_vs_block& _21 [[buffer(0)]])
    {
        main0_out out = {};
        out.gl_Position = (_21.u_proj * _21.u_mv) * float4(in.a_pos, 1.0);
        out.color = in.a_color;
        out.uv = in.a_uv;
        return out;
    }

*/
static const char vs_source_metal_ios[647] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x0a,0x7b,0x0a,0x20,0x20,0x20,
    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x75,0x5f,0x70,0x72,0x6f,0x6a,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x75,
    0x5f,0x6d,0x76,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,
    0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,
    0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,
    0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,
    0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,
    0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,
    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,
    0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,
    0x62,0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,
    0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,0x5f,0x75,0x76,0x20,
    0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,
    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,0x74,0x65,0x78,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,
    0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,
    0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x26,0x20,0x5f,0x32,0x31,
    0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,
    0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,
    0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,
    0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,
    0x28,0x5f,0x32,0x31,0x2e,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x2a,0x20,0x5f,0x32,
    0x31,0x2e,0x75,0x5f,0x6d,0x76,0x29,0x20,0x2a,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,
    0x28,0x69,0x6e,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,
    0x20,0x69,0x6e,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x61,0x5f,0x75,
    0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,
    0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 frag_color [[color(0)]];
    };

    struct main0_in
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.frag_color = u_tex.sample(u_texSmplr, in.uv) * in.color;
        return out;
    }

*/
static const char fs_source_metal_ios[454] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,
    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,
    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,
    0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,
    0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,
    0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,
    0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x3e,0x20,0x75,0x5f,
    0x74,0x65,0x78,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x30,0x29,
    0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,0x75,0x5f,0x74,0x65,
    0x78,0x53,0x6d,0x70,0x6c,0x72,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,
    0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x53,0x6d,0x70,0x6c,0x72,0x2c,0x20,0x69,
    0x6e,0x2e,0x75,0x76,0x29,0x20,0x2a,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_METAL */
#if defined(SOKOL_METAL)
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct pg_vs_block
    {
        float4x4 u_proj;
        float4x4 u_mv;
    };

    struct main0_out
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 a_pos [[attribute(0)]];
        float4 a_color [[attribute(1)]];
        float2 a_uv [[attribute(2)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant pg_vs_block& _21 [[buffer(0)]])
    {
        main0_out out = {};
        out.gl_Position = (_21.u_proj * _21.u_mv) * float4(in.a_pos, 1.0);
        out.color = in.a_color;
        out.uv = in.a_uv;
        return out;
    }

*/
static const char vs_source_metal_sim[647] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x70,
    0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x0a,0x7b,0x0a,0x20,0x20,0x20,
    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x75,0x5f,0x70,0x72,0x6f,0x6a,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x75,
    0x5f,0x6d,0x76,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,
    0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,
    0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,
    0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,
    0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,
    0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,
    0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,
    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,
    0x74,0x33,0x20,0x61,0x5f,0x70,0x6f,0x73,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,
    0x62,0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,
    0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,
    0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,0x5f,0x75,0x76,0x20,
    0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,
    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,0x74,0x65,0x78,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,
    0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,
    0x70,0x67,0x5f,0x76,0x73,0x5f,0x62,0x6c,0x6f,0x63,0x6b,0x26,0x20,0x5f,0x32,0x31,
    0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,
    0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,
    0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,
    0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,
    0x28,0x5f,0x32,0x31,0x2e,0x75,0x5f,0x70,0x72,0x6f,0x6a,0x20,0x2a,0x20,0x5f,0x32,
    0x31,0x2e,0x75,0x5f,0x6d,0x76,0x29,0x20,0x2a,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,
    0x28,0x69,0x6e,0x2e,0x61,0x5f,0x70,0x6f,0x73,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,
    0x20,0x69,0x6e,0x2e,0x61,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x20,0x20,0x20,
    0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x61,0x5f,0x75,
    0x76,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,
    0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
/*
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 frag_color [[color(0)]];
    };

    struct main0_in
    {
        float4 color [[user(locn0)]];
        float2 uv [[user(locn1)]];
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_tex [[texture(0)]], sampler u_texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.frag_color = u_tex.sample(u_texSmplr, in.uv) * in.color;
        return out;
    }

*/
static const char fs_source_metal_sim[454] = {
    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,
    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,
    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,
    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,
    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,
    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,
    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,
    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,
    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,
    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,
    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,
    0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,
    0x32,0x20,0x75,0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,
    0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,
    0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,
    0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x74,0x65,0x78,
    0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,0x3e,0x20,0x75,0x5f,
    0x74,0x65,0x78,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x28,0x30,0x29,
    0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,0x75,0x5f,0x74,0x65,
    0x78,0x53,0x6d,0x70,0x6c,0x72,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,
    0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,
    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,
    0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,
    0x6c,0x6f,0x72,0x20,0x3d,0x20,0x75,0x5f,0x74,0x65,0x78,0x2e,0x73,0x61,0x6d,0x70,
    0x6c,0x65,0x28,0x75,0x5f,0x74,0x65,0x78,0x53,0x6d,0x70,0x6c,0x72,0x2c,0x20,0x69,
    0x6e,0x2e,0x75,0x76,0x29,0x20,0x2a,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,0x72,
    0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,
    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,
};
#endif /* SOKOL_METAL */
static const sg_shader_desc* pg_default_shader_desc(sg_backend backend) {
  #if defined(SOKOL_GLCORE33)
  if (backend == SG_BACKEND_GLCORE33) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.attrs[0].name = "a_pos";
      desc.attrs[1].name = "a_color";
      desc.attrs[2].name = "a_uv";
      desc.vs.source = vs_source_glsl330;
      desc.vs.entry = "main";
      desc.vs.uniform_blocks[0].size = 128;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.vs.uniform_blocks[0].uniforms[0].name = "pg_vs_block";
      desc.vs.uniform_blocks[0].uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;
      desc.vs.uniform_blocks[0].uniforms[0].array_count = 8;
      desc.fs.source = fs_source_glsl330;
      desc.fs.entry = "main";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_GLCORE33 */
  #if defined(SOKOL_GLES3)
  if (backend == SG_BACKEND_GLES3) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.attrs[0].name = "a_pos";
      desc.attrs[1].name = "a_color";
      desc.attrs[2].name = "a_uv";
      desc.vs.source = vs_source_glsl300es;
      desc.vs.entry = "main";
      desc.vs.uniform_blocks[0].size = 128;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.vs.uniform_blocks[0].uniforms[0].name = "pg_vs_block";
      desc.vs.uniform_blocks[0].uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;
      desc.vs.uniform_blocks[0].uniforms[0].array_count = 8;
      desc.fs.source = fs_source_glsl300es;
      desc.fs.entry = "main";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_GLES3 */
  #if defined(SOKOL_D3D11)
  if (backend == SG_BACKEND_D3D11) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.attrs[0].sem_name = "TEXCOORD";
      desc.attrs[0].sem_index = 0;
      desc.attrs[1].sem_name = "TEXCOORD";
      desc.attrs[1].sem_index = 1;
      desc.attrs[2].sem_name = "TEXCOORD";
      desc.attrs[2].sem_index = 2;
      desc.vs.source = vs_source_hlsl5;
      desc.vs.d3d11_target = "vs_5_0";
      desc.vs.entry = "main";
      desc.vs.uniform_blocks[0].size = 128;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_hlsl5;
      desc.fs.d3d11_target = "ps_5_0";
      desc.fs.entry = "main";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_D3D11 */
  #if defined(SOKOL_METAL)
  if (backend == SG_BACKEND_METAL_MACOS) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.vs.source = vs_source_metal_macos;
      desc.vs.entry = "main0";
      desc.vs.uniform_blocks[0].size = 128;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_metal_macos;
      desc.fs.entry = "main0";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_METAL */
  #if defined(SOKOL_METAL)
  if (backend == SG_BACKEND_METAL_IOS) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.vs.source = vs_source_metal_ios;
      desc.vs.entry = "main0";
      desc.vs.uniform_blocks[0].size = 128;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_metal_ios;
      desc.fs.entry = "main0";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_METAL */
  #if defined(SOKOL_METAL)
  if (backend == SG_BACKEND_METAL_SIMULATOR) {
    static sg_shader_desc desc;
    static bool valid;
    if (!valid) {
      valid = true;
      desc.vs.source = vs_source_metal_sim;
      desc.vs.entry = "main0";
      desc.vs.uniform_blocks[0].size = 128;
      desc.vs.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
      desc.fs.source = fs_source_metal_sim;
      desc.fs.entry = "main0";
      desc.fs.images[0].name = "u_tex";
      desc.fs.images[0].image_type = SG_IMAGETYPE_2D;
      desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
      desc.label = "pg_default_shader";
    }
    return &desc;
  }
  #endif /* SOKOL_METAL */
  return 0;
}
static int pg_default_uniformblock_slot(sg_shader_stage stage, const char* ub_name) {
  (void)stage; (void)ub_name;
  if (SG_SHADERSTAGE_VS == stage) {
    if (0 == strcmp(ub_name, "pg_vs_block")) {
      return 0;
    }
  }
  return -1;
}

#define SOKOL_GFX_IMPL
#include "sokol_gfx.h"

#endif //PICO_GFX_IMPLEMENTATION

/*
    ----------------------------------------------------------------------------
    This software is available under two licenses (A) or (B). You may choose
    either one as you wish:
    ----------------------------------------------------------------------------

    (A) The zlib License

    Copyright (c) 2023 James McLean

    This software is provided 'as-is', without any express or implied warranty.
    In no event will the authors be held liable for any damages arising from the
    use of this software.

    Permission is granted to anyone to use this software for any purpose,
    including commercial applications, and to alter it and redistribute it
    freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software in a
    product, an acknowledgment in the product documentation would be appreciated
    but is not required.

    2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

    3. This notice may not be removed or altered from any source distribution.

    ----------------------------------------------------------------------------

    (B) Public Domain (www.unlicense.org)

    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or distribute
    this software, either in source code form or as a compiled binary, for any
    purpose, commercial or non-commercial, and by any means.

    In jurisdictions that recognize copyright laws, the author or authors of
    this software dedicate any and all copyright interest in the software to the
    public domain. We make this dedication for the benefit of the public at
    large and to the detriment of our heirs and successors. We intend this
    dedication to be an overt act of relinquishment in perpetuity of all present
    and future rights to this software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// EoF
